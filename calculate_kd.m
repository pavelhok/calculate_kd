%% License information
% This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
% You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. 

%% Function calculate_kd starts here
function retval = calculate_kd (atlas,scrubbing, skipd, skipkd, excloutliers, reimportcov)


%% Global variables
% clc;
% clear all;
close all;
rootdir='/path_to_data/'; % set your study root directory here

%% Load libraries and change directory

% addpath(genpath('/path_to_spm/')); % Uncomment and add path to SPM12 here
addpath(genpath('/path_to_bct/')); % Add path to brain connectivity toolbox here
addpath(genpath(strcat(rootdir,'scripts'))); % Add path to the folder where scripts are stored if different from rootdir

cd(rootdir);

if ~exist(strcat(rootdir,'exports'), 'dir')
   mkdir('exports')
end

if ~exist(strcat(rootdir,'figures'), 'dir')
   mkdir('figures')
end

%% Load adjacency matrix

atlases={'conn','bna', '', '4kvoxel';...
    'Adjacency_matrix_CONN.mat',...
    'Adjacency_matrix_BNA.mat',...
    '',...
    'Adjacency_matrix_4kVoxel.mat'}; % Replace with extracted matrices

% atlas=2;

if scrubbing == 1
    if atlas == 1 || atlas == 2
        appendix = '_censored';
    else
        appendix = '';
    end
else
    appendix = '';
end

if excloutliers == 1
    appendix = strcat(appendix,'_excl');
end

if ( skipkd == 0 && skipd == 0 ) || reimportcov == 1   
    %% Import data from spreadsheet
    % Auto-generated by MATLAB on 2023/11/10 10:15:53

    % Import the data
    [~, ~, raw] = xlsread(strcat(rootdir,'group_covariates_clinical_harmonized.xlsx'),'Stats'); raw = raw(2:108,:); % Replace with 
    raw(cellfun(@(x) ~isempty(x) && isnumeric(x) && isnan(x),raw)) = {''};

    % Replace non-numeric cells with NaN
    R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
    raw(R) = {NaN}; % Replace non-numeric cells

    % Create output variable
    data = reshape([raw{:}],size(raw));

    % Create table
    Covariates = table;

    % Allocate imported array to column variable names
    Covariates.CONNID = data(:,1);
    Covariates.Study = data(:,2);
    Covariates.Group = data(:,3);
    Covariates.Center = data(:,4);
    Covariates.EXCLUDE_from_Analysis = data(:,5);
    Covariates.EXCLUDE_Outliers = data(:,6);
    Covariates.PatientsALL = data(:,7);
    Covariates.PatientsRight = data(:,8);
    Covariates.PatientsLeft = data(:,9);
    Covariates.Controls = data(:,10);
    Covariates.PatientsALL_noMotion = data(:,11);
    Covariates.PatientsRight_noMotion = data(:,12);
    Covariates.PatientsLeft_noMotion = data(:,13);
    Covariates.Controls_noMotion = data(:,14);
    Covariates.CenterDE = data(:,15);
    Covariates.CenterAU = data(:,16);
    Covariates.PatientsDE_noMotion = data(:,17);
    Covariates.PatientsAU_noMotion = data(:,18);
    Covariates.ControlsDE_noMotion = data(:,19);
    Covariates.ConsolsAU_noMotion = data(:,20);
    Covariates.CenterDE_noMotion = data(:,21);
    Covariates.CenterAU_noMotion = data(:,22);
    Covariates.PainRestCur_harm = data(:,23);
    Covariates.PainRestCur_harm_Right = data(:,24);
    Covariates.PainRestCur_harm_Left = data(:,25);
    Covariates.CRPSDur = data(:,26);
    Covariates.CRPSDur_noMotion = data(:,27);
    Covariates.CRPSDur_Right_noMotion = data(:,28);
    Covariates.CRPSDur_Left_noMotion = data(:,29);
    Covariates.CRPSDur_harm = data(:,30);
    Covariates.CSS = data(:,31);
    Covariates.CSS_noMotion = data(:,32);
    Covariates.TPD_harm = data(:,33);
    Covariates.SICI = data(:,34);
    Covariates.SICI_ALL_noMotion = data(:,35);
    Covariates.SICI_Patients_noMotion = data(:,36);

    % Clear temporary variables
    clearvars data raw R;
    
end
        
if skipkd == 0
    if skipd == 0

        load (atlases{2,atlas})

        %nconditions = matrices.nconditions; %adjancency matrices for this project saved without matrices struct
        nconditions = 1;
        %Z = matrices.condition(1).Z;
        % names = matrices.condition(1).names;
        %nsubj = size(matrices.condition(1).Z,3);
        nsubj = size(Z,3);
        conditioncode = zeros (nsubj,1) + 1;
        Zsize = nsubj * nconditions;
        %nrois = size(matrices.condition(1).Z,1);
        nrois = size(Z,1);

        if nconditions > 1
            for c = 2:nconditions
                Z = cat(3,Z,matrices.condition(c).Z);
                conditioncode = cat(1,conditioncode,conditioncode * c);
            end
        end

        clear c;

        %% Find missing data

        missingdata = zeros (Zsize,1);

        for s = 1:Zsize
           if sum(sum(isnan(Z(:,:,s)))) > nrois
               missingdata(s) = 1;
           end
        end

        clear s;
		
        
        %% Import ROI definitions and brain mask overlap, discard connections outside the brain
        if scrubbing == 1
            if atlas == 1
                importf = 'mask_overlap_CONN.xlsx';
            elseif atlas == 2
                importf = 'mask_overlap_BNA.xlsx';
            end
            if atlas == 1 || atlas == 2
                othresh = 50;
                % Auto-generated by MATLAB on 2022/11/09 09:56:42

                % Import the data
                [~, ~, raw] = xlsread(strcat(rootdir,importf));
                raw = raw(2:end,:);
                stringVectors = string(raw(:,2));
                stringVectors(ismissing(stringVectors)) = '';
                raw = raw(:,[1,3,4,5]);

                % Create output variable
                data = reshape([raw{:}],size(raw));

                % Create table
                maskoverlap = table;

                % Allocate imported array to column variable names
                maskoverlap.ID = data(:,1);
                maskoverlap.Mask = stringVectors(:,1);
                maskoverlap.Original_vol = data(:,2);
                maskoverlap.Masked_vol = data(:,3);
                maskoverlap.Percent = data(:,4);

                % Clear temporary variables
                clearvars data raw stringVectors;

                keepvec = maskoverlap.Percent;
                keepvec(keepvec < othresh) = 0;
                keepvec(keepvec > othresh) = 1;
                discardind = find(keepvec == 0);

                Z(discardind,:,:) = [];
                Z(:,discardind,:) = [];
                nrois = size(Z,1);
            end
        end

        clear maskoverlap;
        %% Threshold matrix, get nodal degree

        pthresh = 0.1; % preserve 10 % connections (Mansour et al. 2016)

        plabel = strcat(num2str(pthresh * 100),"pct");

        Zthr = Z * 0;

        for s = 1:Zsize
            if missingdata(s) ~= 1
                Zthr(:,:,s) = threshold_proportional(Z(:,:,s),pthresh);
            else
                Zthr(:,:,s) = NaN;
            end
        end

        Zbin = Zthr;
        Zbin(Zbin ~= 0) = 1;

        % Visualize

        f = imagesc(nanmean(Zbin,3));
        saveas(f,strcat('figures/Mean_Zbin_',plabel,'_',atlases(1,atlas),appendix,'.jpg'));
        close all
        clear f
        
        % Get nodal degree

        D.raw = zeros (Zsize,nrois);

        for s = 1:Zsize
            if missingdata(s) ~= 1
                D.raw(s,:) = degrees_und (Zbin(:,:,s));
            else
                D.raw(s,:) = NaN;
            end
        end
        
        %roinames = matrices.condition(1).names; %adjancency matrices for this project saved without matrices struct
        roinames = names;

        %clear f s Zthr Z Zbin matrices;
        clear f s Zthr Z Zbin names;
		
        save (strcat('D_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));

    else
        % The following code with temporary storage fixes a known bug, that would overwrite any previously saved variables
        tmpstring = strcat('Temporary_init_workspace_',string(atlases(1,atlas)),string(appendix),'.mat');
        save (tmpstring);
        load (strcat('D_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
        load (tmpstring);
        clear tmpstring
    end

    %% Set groups
    centers = {'Germany','Australia';'DE','AU'};
    ncenters = size(centers,2);
    groups = {'Patients','Controls'; 'Pat','HC'};
    ngroups = size(groups,2);
    studies = {'Greifswald CRPS2019','Mental Rotation','Sydney CRPS';'CRPSDE2019','MENTROT','CRPSAU'; 1, 2, 3};
    nstudies = size(studies,2);

    conditions = {'Baseline'; 'Baseline'};
    controlgrp = 2;
    controlcond = 1;

    % Define centers, studies and groups
    grpstruct.centers = centers;
    grpstruct.ncenters = ncenters;

    for ce = 1:grpstruct.ncenters
        %grpstruct.ce(ce).studies = studies;
        %grpstruct.ce(ce).nstudies = nstudies;
        if ce == 1
            grpstruct.ce(ce).studies = studies(:,[1 2]);
        else
            grpstruct.ce(ce).studies = studies(:,[3]); 
        end
        grpstruct.ce(ce).nstudies = size(grpstruct.ce(ce).studies,2);
        grpstruct.ce(ce).all.groups = groups;
        grpstruct.ce(ce).all.ngroups = ngroups;
        for s = 1:grpstruct.ce(ce).nstudies
            grpstruct.ce(ce).s(s).groups = grpstruct.ce(ce).all.groups;
            grpstruct.ce(ce).s(s).ngroups = grpstruct.ce(ce).all.ngroups;
        end
    end

    % Setup exclusion
	condition(1).exclude = Covariates.EXCLUDE_from_Analysis == 1 | missingdata(conditioncode == 1) == 1;
    if excloutliers
        condition(1).exclude = condition(1).exclude == 1 | Covariates.EXCLUDE_Outliers == 1;
    end

    groupcode = Covariates.Group;
    if nconditions > 1 
        for c = 2:nconditions
            groupcode = cat(1,groupcode,Covariates.Group);
        end
    end

    centercode = Covariates.Center;
    if nconditions > 1 
        for c = 2:nconditions
            centercode = cat(1,centercode,Covariates.Center);
        end
    end

    studycode = Covariates.Study;
    if nconditions > 1 
        for c = 2:nconditions
            studycode = cat(1,studycode,Covariates.Study);
        end
    end

    excludecode = condition(1).exclude;
    if nconditions > 1 
        for c = 2:nconditions
            excludecode = cat(1,excludecode,condition(c).exclude);
        end
    end

    condition(1).excludeid = Covariates.CONNID(condition(1).exclude);

    groupcode_excl = groupcode;
    groupcode_excl(excludecode == 1) = 0;

    % Get overall D across centers
    for g = 1:ngroups
        for co = 1:nconditions
            D.all.g(g).co(co).raw = D.raw(groupcode_excl == g & conditioncode == co,:);
            D.all.g(g).co(co).mean = mean(D.all.g(g).co(co).raw,1);
        end
    end
    
    for g = 1:ngroups
        for co = 1:nconditions
            D.all.g(g).co(co).alldiff = D.all.g(g).co(co).raw - D.all.g(controlgrp).co(controlcond).mean;
        end
    end
    
    % Get overall D across studies
    D.mergednel = 0;
    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions
                D.ce(ce).all.g(g).co(co).raw = D.raw(centercode == ce & groupcode_excl == g & conditioncode == co,:);
                D.ce(ce).all.g(g).co(co).mean = mean(D.ce(ce).all.g(g).co(co).raw,1);
                D.mergednel = D.mergednel + 1;
            end
        end
    end
    
    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions
                D.ce(ce).all.g(g).co(co).dirdiff = D.ce(ce).all.g(g).co(co).raw - D.ce(ce).all.g(controlgrp).co(controlcond).mean;
                D.ce(ce).all.g(g).co(co).alldiff = D.ce(ce).all.g(g).co(co).raw - D.all.g(controlgrp).co(controlcond).mean;
                if grpstruct.ncenters == 2
                    if ce == 1
                        D.ce(ce).all.g(g).co(co).crossdiff = D.ce(ce).all.g(g).co(co).raw - D.ce(2).all.g(controlgrp).co(controlcond).mean;
                    else
                        D.ce(ce).all.g(g).co(co).crossdiff = D.ce(ce).all.g(g).co(co).raw - D.ce(1).all.g(controlgrp).co(controlcond).mean;
                    end
                end
            end
        end
    end
        
    % Get separate D for each center/study
    D.nel = 0;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    D.ce(ce).s(s).g(g).co(co).raw = D.raw(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == g & conditioncode == co,:);
                    grpstruct.ce(ce).s(s).g(g).co(co).size = size(D.ce(ce).s(s).g(g).co(co).raw,1);
                    D.ce(ce).s(s).g(g).co(co).mean = mean(D.ce(ce).s(s).g(g).co(co).raw,1);
                    D.nel = D.nel + 1;
                end
            end
        end
    end

    for ce = 1:grpstruct.ncenters
        grpstruct.ce(ce).controlsize = sum(centercode == ce & groupcode_excl == controlgrp & conditioncode == controlcond);
        for s = 1:grpstruct.ce(ce).nstudies
            grpstruct.ce(ce).s(s).controlsize = sum(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == controlgrp & conditioncode == controlcond);
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    D.ce(ce).s(s).g(g).co(co).dirdiff = D.ce(ce).s(s).g(g).co(co).raw - D.ce(ce).s(s).g(controlgrp).co(controlcond).mean;
                    D.ce(ce).s(s).g(g).co(co).alldiff = D.ce(ce).s(s).g(g).co(co).raw - D.all.g(controlgrp).co(controlcond).mean;
                end
            end
        end
    end
    
    maxall = zeros(1,D.nel);
    minall = zeros(1,D.nel);
    i=1;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    maxall(i) = max(D.ce(ce).s(s).g(g).co(co).mean);
                    minall(i) = min(D.ce(ce).s(s).g(g).co(co).mean);
                    i=i+1;
                end
            end
        end
    end
    minmaxall = [min(minall) max(maxall)];

    imgscmat = zeros (D.nel,nrois);
    imgsclabel = cell(1, D.nel);
    imgscticks = zeros(1,D.nel);
    r = 1;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    imgscmat(r,:) = D.ce(ce).s(s).g(g).co(co).mean;              
                    imgsclabel(1,r) = strcat(centers(2,ce),'-',grpstruct.ce(ce).studies(1,s),'-',groups(2,g),'-',conditions(2,co)); %studies(2,s)
                    imgscticks(1,r) = r;
                    r = r + 1;
                end
            end
        end
    end
    f = imagesc(imgscmat);
    ax = gca;
    ax.YTick = imgscticks;
    ax.YTickLabel = imgsclabel;
    saveas(f,strcat('figures/Mean_D_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

    close all;
    clear f r ce s g co c imgsclabel imgscticks imgscmat ax;

    %% Distribution of D
    % Not universal

    nbins = 20;
    if atlas == 1
        ylims = [0 20];
    elseif atlas == 2
        ylims = [0 40];
    else
        ylims = [0 700];
    end

    xlims = [0 minmaxall(2)];

    for ce = 1:ncenters
        for co = 1:nconditions
            f = figure('Name','D distribution');

            set(gcf,'position',[100,100,400.*grpstruct.ce(ce).nstudies,400.*grpstruct.ce(ce).all.ngroups])
            
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    subploth = subplot(grpstruct.ce(ce).s(s).ngroups,grpstruct.ce(ce).nstudies,s+(g-1).*grpstruct.ce(ce).nstudies);
                    histogram(D.ce(ce).s(s).g(g).co(co).mean,nbins)
                    ylim(subploth, ylims);
                    xlim(subploth, xlims);
                    title(strcat(groups(2,g),'-',grpstruct.ce(ce).studies(1,s)));
                end
            end
            
            saveas(f,strcat('figures/D_histogram_',centers(2,ce),'_',...
                conditions(2,co),'_',plabel,'_',atlases(1,atlas),appendix,'.tif'));
            close all;
        end
    end
    
    clear f ylims xlims nbins subploth;

    %% CDF plots
    % Not universal
      
    for ce = 1:ncenters
        for co = 1:nconditions

            f = figure('Name','CDF');

            i=1;
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    if ~isnan(nanmean(D.ce(ce).s(s).g(g).co(co).mean))
                        cdfplots(i) = cdfplot(D.ce(ce).s(s).g(g).co(co).mean);
                        legends(i) = strcat(groups(2,g),"-",grpstruct.ce(ce).studies(1,s));
                        hold on
                        i=i+1;
                    end
                end
            end
            
            xvals = linspace(minmaxall(1),minmaxall(2));
            cdfplots(i) = plot(xvals,normcdf(xvals,mean(D.all.g(controlgrp).co(controlcond).mean),std(D.all.g(controlgrp).co(controlcond).mean)),'r-');
            legends(i) = {'Normal'};
            
            title('CDF Mean Degree');
            
            legend(cdfplots,legends,'Location','southeast');

            saveas(f,strcat('figures/D_cdf_',centers(2,ce),'_',...
                conditions(2,co),'_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

            close all;
            clear cdfplots legends;
        end
    end
    
    f = figure('Name','CDF_merged');

    i=1;
    for g = 1:ngroups
        for co = 1:nconditions
            cdfplots(i) = cdfplot(D.all.g(g).co(co).mean);
            legends(i) = strcat(groups(2,g),"-",conditions(2,co));
            hold on
            i=i+1;
        end
    end

    xvals = linspace(minmaxall(1),minmaxall(2));
    cdfplots(i) = plot(xvals,normcdf(xvals,mean(D.all.g(controlgrp).co(controlcond).mean),std(D.all.g(controlgrp).co(controlcond).mean)),'r-');
    legends(i) = {'Normal'};

    title('CDF Mean Degree Merged');

    legend(cdfplots,legends,'Location','southeast');

    saveas(f,strcat('figures/D_cdf_merged_',plabel,'_',atlases(1,atlas),appendix,'.tif'));
    close all;
    clear f textboxdim1 textboxstr1 h1 p1 cdfplots legends xvals;

    %% Compare D
    % Not universal
    p(1).v = zeros(nrois,1) + 1;
    h(1).v = zeros(nrois,1);

    for roi = 1:nrois
        [p(1).v(roi),h(1).v(roi)] = ranksum(D.all.g(1).co(1).raw(:,roi),D.all.g(2).co(1).raw(:,roi));
    end

    hcor(1).v = zeros(size(p(1).v,1),1);
    pcor=0.05./nrois;
    hcor(1).v(p(1).v < pcor) = 1;
    
    f = imagesc([p(1).v,h(1).v,hcor(1).v]);
    ax = gca;
    ax.XTick = 1:3;
    ax.XTickLabel = [strcat(groups(2,1)," - ",groups(2,2)),{'h'},{"h (Bonferroni)"}];
    xtickangle (90);
    if atlas == 1
        ax.YTick = 1:nrois;
        ax.YTickLabel = roinames;
        set(gcf,'position',[50,50,800,2000]);
        ax.FontSize = 6;
    end
    saveas(f,strcat('figures/D_diff_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

    close all;
    clear f p h ax;


    %% Get kD

    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    kD.ce(ce).s(s).g(g).co(co).dirdiff = zeros(size(D.ce(ce).s(s).g(g).co(co).dirdiff,1),2);
                    kD.ce(ce).s(s).g(g).co(co).alldiff = zeros(size(D.ce(ce).s(s).g(g).co(co).alldiff,1),2);
                    for su = 1:size(kD.ce(ce).s(s).g(g).co(co).dirdiff,1)
                        kD.ce(ce).s(s).g(g).co(co).dirdiff(su,:) = polyfit(D.ce(ce).s(s).g(controlgrp).co(controlcond).mean, D.ce(ce).s(s).g(g).co(co).dirdiff(su,:),1);
                        kD.ce(ce).s(s).g(g).co(co).alldiff(su,:) = polyfit(D.all.g(controlgrp).co(controlcond).mean, D.ce(ce).s(s).g(g).co(co).alldiff(su,:),1);
                    end
                end
            end
        end
    end
    
    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions
                kD.ce(ce).all.g(g).co(co).dirdiff = zeros(size(D.ce(ce).all.g(g).co(co).dirdiff,1),2);
                kD.ce(ce).all.g(g).co(co).alldiff = zeros(size(D.ce(ce).all.g(g).co(co).alldiff,1),2);
                if grpstruct.ncenters == 2
                    kD.ce(ce).all.g(g).co(co).crossdiff = zeros(size(D.ce(ce).all.g(g).co(co).crossdiff,1),2);
                end
                for su = 1:size(kD.ce(ce).all.g(g).co(co).dirdiff,1)
                    kD.ce(ce).all.g(g).co(co).dirdiff(su,:) = polyfit(D.ce(ce).all.g(controlgrp).co(controlcond).mean, D.ce(ce).all.g(g).co(co).dirdiff(su,:),1);
                    kD.ce(ce).all.g(g).co(co).alldiff(su,:) = polyfit(D.all.g(controlgrp).co(controlcond).mean, D.ce(ce).all.g(g).co(co).alldiff(su,:),1);
                    if grpstruct.ncenters == 2
                        if ce == 1
                            kD.ce(ce).all.g(g).co(co).crossdiff(su,:) = polyfit(D.ce(2).all.g(controlgrp).co(controlcond).mean, D.ce(ce).all.g(g).co(co).crossdiff(su,:),1);
                        else
                            kD.ce(ce).all.g(g).co(co).crossdiff(su,:) = polyfit(D.ce(1).all.g(controlgrp).co(controlcond).mean, D.ce(ce).all.g(g).co(co).crossdiff(su,:),1);
                        end
                    end
                end
            end
        end
    end
    
    % unused
    for g = 1:ngroups
        for co = 1:nconditions
            kD.all.g(g).co(co).alldiff = zeros(size(D.all.g(g).co(co).alldiff,1),2);
            for su = 1:size(kD.all.g(g).co(co).alldiff,1)
                kD.all.g(g).co(co).alldiff(su,:) = polyfit(D.all.g(controlgrp).co(controlcond).mean, D.all.g(g).co(co).alldiff(su,:),1);
            end
        end
    end

    clear g ce co s su;

    %% Get kD permuted with random half controls - separate studies
    nperms = 0; % Permutation counter
    minperms = 100; % Set target number of permutations
    permsdone = false;

    for ce = 1:ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            grpstruct.ce(ce).s(s).perm.halfcontrolsize = fix(grpstruct.ce(ce).s(s).controlsize/2);
            grpstruct.ce(ce).s(s).perm.nassig = zeros(grpstruct.ce(ce).s(s).controlsize,2); %column 1 - for normalisation, 2 - for t-test
        end
    end

    % Declare empty containers

    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm = zeros(size(D.ce(ce).s(s).g(g).co(co).raw,1),minperms);
                    D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).raw * 0;
                    if g == controlgrp
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm == 0) = NaN;
                        D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).s(s).g(g).co(co).raw * 0;
                    end
                end
            end
        end
    end

    % Start permutations here
    while (permsdone == false)
        nperms = nperms + 1;
        % Set random control groupsPat_DE
        permcode = groupcode_excl * 0;

        % For each center
        for ce = 1:ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                % Chose a random sample from the control groups
                grpstruct.ce(ce).s(s).perm.cons4norm = randsample(find(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == controlgrp),grpstruct.ce(ce).s(s).perm.halfcontrolsize);
                permcode(grpstruct.ce(ce).s(s).perm.cons4norm) = 1; % For normalization
                permcode(permcode == 0 & centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == controlgrp) = 2; % For t-test
            end
        end

        % For each center, study, group, condition
        for ce = 1:grpstruct.ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    for co = 1:nconditions
                        % If condition is control condition (e.g., baseline)
                        % and group is control group
                        if co == controlcond && g == controlgrp
                            % Extract degree for the testing set, set controls for normalization to NaN
                            D.temp = D.raw;
                            D.temp(permcode == 1,:) = NaN;
                            D.ce(ce).s(s).g(g).co(co).halfdiff.forttest_raw = D.temp(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == g & conditioncode == co,:);                       
                            % Extract degree for the normalization set
                            D.temp = D.raw;
                            D.temp(permcode == 2,:) = NaN;
                            D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw = D.temp(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == g & conditioncode == co,:);
                            % Get average degree
                            D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_mean = nanmean(D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw);
                        end
                    end
                end
            end
        end

        for ce = 1:grpstruct.ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    for co = 1:nconditions
                        % If condition is control condition (e.g., baseline)
                        % and group is control group
                        if co == controlcond && g == controlgrp
                            % Calculate the degree difference
                            D.ce(ce).s(s).g(g).co(co).halfdiff.diff = D.ce(ce).s(s).g(g).co(co).halfdiff.forttest_raw ...
                                - D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                        % For all remaining cases if permutation counter is lower or equal to
                        % target number
                        elseif nperms <= minperms
                            % Calculate the degree difference
                            D.ce(ce).s(s).g(g).co(co).halfdiff.diff = D.ce(ce).s(s).g(g).co(co).raw ...
                                - D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                        end

                        % Calculate kD 
                        % If permutation counter is lower or equal to
                        % target number or if control group is computed
                        if nperms <= minperms || ( co == controlcond && g == controlgrp ) 
                            kD.ce(ce).s(s).g(g).co(co).halfdiff.single = zeros(size(D.ce(ce).s(s).g(g).co(co).halfdiff.diff,1),2);
                            for su = 1:size(D.ce(ce).s(s).g(g).co(co).halfdiff.diff,1)
                                kD.ce(ce).s(s).g(g).co(co).halfdiff.single(su,:) = ...
                                    polyfit(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean, ...
                                    D.ce(ce).s(s).g(g).co(co).halfdiff.diff(su,:),1);
                            end
                            % Store kD separately for each permutation
                            kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm(:,nperms) = kD.ce(ce).s(s).g(g).co(co).halfdiff.single(:,1);

                            if co == controlcond && g == controlgrp
                                % Remove NaNs
                                D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan = D.ce(ce).s(s).g(g).co(co).halfdiff.diff;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan(isnan(D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan)) = 0;

                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan(isnan(D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan)) = 0;
                                % Add difference in degree to a total sum (to get later mean degree)
                                D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan;
                            else
                                % Add difference in degree to a total sum (to get later mean degree)
                                D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.diff;
                            end
                        end
                    end
                end
            end
        end

        % Increment assigment counters
        currentmin = minperms;
        for ce = 1:ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                grpstruct.ce(ce).s(s).perm.nassig(:,1) = grpstruct.ce(ce).s(s).perm.nassig(:,1) ...
                    + isnan(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.diff(:,1));
                grpstruct.ce(ce).s(s).perm.nassig(:,2) = grpstruct.ce(ce).s(s).perm.nassig(:,2) ...
                    + isnan(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_raw(:,1));
                if (min(grpstruct.ce(ce).s(s).perm.nassig(:,2)) < currentmin)
                    currentmin = min(grpstruct.ce(ce).s(s).perm.nassig(:,2));
                end
            end
        end

        % Check if targent number of permutations was reached in all controls
        if currentmin >= minperms
            % If yes, break loop
            permsdone = true;
        end
    end

    for ce = 1:ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    % For the control group
                    if co == controlcond && g == controlgrp
                        % Get first minperms (100) values for controls, ignore the rest
                        kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans = ...
                            zeros(size(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.diff,1),minperms);
                        for su = 1:size(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm,1) 
                            kD.temp = kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm(su,:);
                            kD.temp = kD.temp(~isnan(kD.temp));
                            kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans(su,:) = ...
                                kD.temp(1:minperms);
                        end
                        % Get mean kD for each permutation averaged across subjects (first minperms)
                        % The following line does actually average across
                        % fewer datapoints, but using "nonans" is not informative 
                        % as permutations get mixed with each other.
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanperperm = nanmean(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm(:,1:minperms),1);
                        % Get mean kD for each subject averaged across permutations (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans,2);
                        % Get mean degree (for visualization only)
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ./ grpstruct.ce(ce).s(s).perm.nassig(:,2);
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean_fornorm = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum ./ grpstruct.ce(ce).s(s).perm.nassig(:,1);
                    % For all the remaninig subjects
                    else
                        % Get mean kD for each permutation averaged across subjects (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanperperm = mean(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm,1);
                        % Get mean kD for each subject averaged across permutations (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm,2);
                        % Get mean degree (for visualization only)
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ./ minperms;
                    end
                end
            end

        end
    end
    
    clear kD.temp
    
    %% Get kD permuted with random half controls - merge studies within center
    nperms = 0; % Permutation counter
    minperms = 100; % Set target number of permutations
    permsdone = false;

    for ce = 1:ncenters
        % Get the size of the halved control group, ignore studies
        grpstruct.ce(ce).perm.halfcontrolsize = fix(grpstruct.ce(ce).controlsize/2);
        grpstruct.ce(ce).all.perm.nassig = zeros(grpstruct.ce(ce).controlsize,2); %column 1 - for normalisation, 2 - for t-test
    end

    % Declare empty containers

    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions
                kD.ce(ce).all.g(g).co(co).halfdiff.perperm = zeros(size(D.ce(ce).all.g(g).co(co).raw,1),minperms);
                D.ce(ce).all.g(g).co(co).halfdiff.sum = D.ce(ce).all.g(g).co(co).raw * 0;
                if g == controlgrp
                    kD.ce(ce).all.g(g).co(co).halfdiff.perperm(kD.ce(ce).all.g(g).co(co).halfdiff.perperm == 0) = NaN;
                    D.ce(ce).all.g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).all.g(g).co(co).raw * 0;
                end
            end
        end
    end

    % Start permutations here
    while (permsdone == false)
        nperms = nperms + 1;
        % Set random control groupsPat_DE
        permcode = groupcode_excl * 0;

        % For each center
        for ce = 1:ncenters
            % Chose a random sample from the control groups (ignore division
            % into studies)
            grpstruct.ce(ce).perm.cons4norm = randsample(find(centercode == ce & groupcode_excl == controlgrp),grpstruct.ce(ce).perm.halfcontrolsize);
            permcode(grpstruct.ce(ce).perm.cons4norm) = 1; % For normalization
            permcode(permcode == 0 & centercode == ce & groupcode_excl == controlgrp) = 2; % For t-test
        end

        % For each center, study, group, condition
        for ce = 1:grpstruct.ncenters
            for g = 1:grpstruct.ce(ce).all.ngroups
                for co = 1:nconditions
                    % If condition is control condition (e.g., baseline)
                    % and group is control group
                    if co == controlcond && g == controlgrp
                        % Extract degree for the testing set, set controls for normalization to NaN
                        D.temp = D.raw;
                        D.temp(permcode == 1,:) = NaN;
                        D.ce(ce).all.g(g).co(co).halfdiff.forttest_raw = D.temp(centercode == ce & groupcode_excl == g & conditioncode == co,:);                       
                        % Extract degree for the normalization set
                        D.temp = D.raw;
                        D.temp(permcode == 2,:) = NaN;
                        D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw = D.temp(centercode == ce & groupcode_excl == g & conditioncode == co,:);
                        % Get average degree
                        D.ce(ce).all.g(g).co(co).halfdiff.fornorm_mean = nanmean(D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw);
                    end
                end
            end
        end

        for ce = 1:grpstruct.ncenters
            for g = 1:grpstruct.ce(ce).all.ngroups
                for co = 1:nconditions
                    % If condition is control condition (e.g., baseline)
                    % and group is control group
                    if co == controlcond && g == controlgrp
                        % Calculate the degree difference
                        D.ce(ce).all.g(g).co(co).halfdiff.diff = D.ce(ce).all.g(g).co(co).halfdiff.forttest_raw ...
                            - D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                    % For all remaining cases if permutation counter is lower or equal to
                    % target number
                    elseif nperms <= minperms
                        % Calculate the degree difference
                        D.ce(ce).all.g(g).co(co).halfdiff.diff = D.ce(ce).all.g(g).co(co).raw ...
                            - D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                    end

                    % Calculate kD 
                    % If permutation counter is lower or equal to
                    % target number or if control group is computed
                    if nperms <= minperms || ( co == controlcond && g == controlgrp ) 
                        kD.ce(ce).all.g(g).co(co).halfdiff.single = zeros(size(D.ce(ce).all.g(g).co(co).halfdiff.diff,1),2);
                        for su = 1:size(D.ce(ce).all.g(g).co(co).halfdiff.diff,1)
                            kD.ce(ce).all.g(g).co(co).halfdiff.single(su,:) = ...
                                polyfit(D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.fornorm_mean, ...
                                D.ce(ce).all.g(g).co(co).halfdiff.diff(su,:),1);
                        end
                        % Store kD separately for each permutation
                        kD.ce(ce).all.g(g).co(co).halfdiff.perperm(:,nperms) = kD.ce(ce).all.g(g).co(co).halfdiff.single(:,1);

                        if co == controlcond && g == controlgrp
                            % Remove NaNs
                            D.ce(ce).all.g(g).co(co).halfdiff.diff_nonan = D.ce(ce).all.g(g).co(co).halfdiff.diff;
                            D.ce(ce).all.g(g).co(co).halfdiff.diff_nonan(isnan(D.ce(ce).all.g(g).co(co).halfdiff.diff_nonan)) = 0;

                            D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw_nonan = D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw;
                            D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw_nonan(isnan(D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw_nonan)) = 0;
                            % Add difference in degree to a total sum (to get later mean degree)
                            D.ce(ce).all.g(g).co(co).halfdiff.sum = D.ce(ce).all.g(g).co(co).halfdiff.sum ...
                                + D.ce(ce).all.g(g).co(co).halfdiff.diff_nonan;
                            D.ce(ce).all.g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).all.g(g).co(co).halfdiff.fornorm_sum ...
                                + D.ce(ce).all.g(g).co(co).halfdiff.fornorm_raw_nonan;
                        else
                            % Add difference in degree to a total sum (to get later mean degree)
                            D.ce(ce).all.g(g).co(co).halfdiff.sum = D.ce(ce).all.g(g).co(co).halfdiff.sum ...
                                + D.ce(ce).all.g(g).co(co).halfdiff.diff;
                        end
                    end
                end
            end
        end

        % Increment assigment counters
        currentmin = minperms;
        for ce = 1:ncenters
            grpstruct.ce(ce).all.perm.nassig(:,1) = grpstruct.ce(ce).all.perm.nassig(:,1) ...
                + isnan(D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.diff(:,1));
            grpstruct.ce(ce).all.perm.nassig(:,2) = grpstruct.ce(ce).all.perm.nassig(:,2) ...
                + isnan(D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.fornorm_raw(:,1));
            if (min(grpstruct.ce(ce).all.perm.nassig(:,2)) < currentmin)
                currentmin = min(grpstruct.ce(ce).all.perm.nassig(:,2));
            end
        end

        % Check if targent number of permutations was reached in all controls
        if currentmin >= minperms
            % If yes, break loop
            permsdone = true;
        end
    end

    for ce = 1:ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions
                % For the control group
                if co == controlcond && g == controlgrp
                    % Get first minperms (100) values for controls, ignore the rest
                    kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm_nonans = ...
                        zeros(size(D.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.diff,1),minperms);
                    for su = 1:size(kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm,1) 
                        kD.temp = kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm(su,:);
                        kD.temp = kD.temp(~isnan(kD.temp));
                        kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm_nonans(su,:) = ...
                            kD.temp(1:minperms);
                    end
                    % Get mean kD for each permutation averaged across subjects (first minperms)
                    % The following line does actually average across
                    % fewer datapoints, but using "nonans" is not informative 
                    % as permutations get mixed with each other.
                    kD.ce(ce).all.g(g).co(co).halfdiff.meanperperm = nanmean(kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm(:,1:minperms),1);
                    % Get mean kD for each subject averaged across permutations (first minperms)
                    kD.ce(ce).all.g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).all.g(controlgrp).co(controlcond).halfdiff.perperm_nonans,2);
                    % Get mean degree (for visualization only)
                    D.ce(ce).all.g(g).co(co).halfdiff.mean = D.ce(ce).all.g(g).co(co).halfdiff.sum ./ grpstruct.ce(ce).all.perm.nassig(:,2);
                    D.ce(ce).all.g(g).co(co).halfdiff.mean_fornorm = D.ce(ce).all.g(g).co(co).halfdiff.fornorm_sum ./ grpstruct.ce(ce).all.perm.nassig(:,1);
                % For all the remaninig subjects
                else
                    % Get mean kD for each permutation averaged across subjects (first minperms)
                    kD.ce(ce).all.g(g).co(co).halfdiff.meanperperm = mean(kD.ce(ce).all.g(g).co(co).halfdiff.perperm,1);
                    % Get mean kD for each subject averaged across permutations (first minperms)
                    kD.ce(ce).all.g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).all.g(g).co(co).halfdiff.perperm,2);
                    % Get mean degree (for visualization only)
                    D.ce(ce).all.g(g).co(co).halfdiff.mean = D.ce(ce).all.g(g).co(co).halfdiff.sum ./ minperms;
                end
            end
        end
    end

    clear s g ce co su permcode permsdone currentmin

    %% Fix for the control group - copy kD

    %ce = 1;
    %s = 1; 
    %g = 2;
    %co = 2;


    % subgroupindex = [1:3,5,7:8,10:11,13:19];

    % Get mean kD for each subject averaged across permutations (first minperms)
    %kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).s(s).g(g).co(1).halfdiff.perperm_nonans(controlsv3index,:),2);
    %kD.ce(ce).s(s).g(g).co(co).halfdiff.meanperperm = nanmean(kD.ce(ce).s(s).g(g).co(1).halfdiff.perperm(controlsv3index,1:minperms),1);

    %clear ce s g co 

    save (strcat('kD_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
    
else
    % The following hotfix with temporary storage fixes a known bug, that would overwrite any previously saved variables
    tmpstring = strcat('Temporary_init_workspace_',string(atlases(1,atlas)),string(appendix),'.mat');

    save (tmpstring);
    
    load (strcat('kD_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
    
    load (tmpstring);
    
    clear tmpstring
end

%% Export D
DOutput = array2table(D.raw.');

tablefn = strcat('exports/d_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    delete (tablefn);
    writetable(DOutput,tablefn);
        
clear tvartypes DOutput r g co tablefn;

%% Export kD

kdmethods = {'Within-center contrast (non-randomized)', 'Within-center contrast', 'Cross-center contrast', 'Pooled centers';...
    'dir','half','crossed','all'};

tvartypes = cell(1,ngroups+1);

tvartypes(1) = {'int16'};
for g = 1:ngroups
    tvartypes(g+1) = {'double'};
end

% Separate studies
for n = 1:size(kdmethods,2)

    kDOutput = table('Size',[nsubj ngroups + 1],'VariableTypes',tvartypes, 'VariableNames',[{'CONN_ID'} groups(1,:)]);
    kDOutput.(1) = Covariates.CONNID;
    
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions    
                    includeid = Covariates.CONNID(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == g & conditioncode == co);       
                    kDOutput.(g+1)(:) = NaN;
                    if n == 1
                       kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).dirdiff(:,1);
                    elseif n == 2
                       kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub;
%                     elseif n == 3
%                        kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).crossdiff(:,1);
                    elseif n == 4
                       kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).alldiff(:,1);
                    end
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_byGrp_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    if isfile(tablefn)
        delete (tablefn);
    end
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput ce s g co;

end

% Merged studies
for n = 1:size(kdmethods,2)

    kDOutput = table('Size',[nsubj ngroups + 1],'VariableTypes',tvartypes, 'VariableNames',[{'CONN_ID'} groups(1,:)]);
    kDOutput.(1) = Covariates.CONNID;
    
    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions    
                includeid = Covariates.CONNID(centercode == ce & groupcode_excl == g & conditioncode == co);       
                kDOutput.(g+1)(:) = NaN;
                if n == 1
                   kDOutput.(g+1)(includeid) = kD.ce(ce).all.g(g).co(co).dirdiff(:,1);
                elseif n == 2
                   kDOutput.(g+1)(includeid) = kD.ce(ce).all.g(g).co(co).halfdiff.meanpersub;
                elseif n == 3
                   kDOutput.(g+1)(includeid) = kD.ce(ce).all.g(g).co(co).crossdiff(:,1);
                elseif n == 4
                   kDOutput.(g+1)(includeid) = kD.ce(ce).all.g(g).co(co).alldiff(:,1);
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_byGrp_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'_mergedStudies.xlsx');
    if isfile(tablefn)
        delete (tablefn);
    end
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput ce s g co;

end

clear tvartypes n;

% Merged output for SPSS
tvartypes = {'int8', 'double'};

% Separate studies
for n = 1:size(kdmethods,2)

    kDOutput = table('Size',[nsubj 2],'VariableTypes',tvartypes, 'VariableNames',{'CONN_ID', 'kD'});
    kDOutput.(1) = Covariates.CONNID;
    kDOutput.(2)(:) = NaN;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions  
                    includeid = Covariates.CONNID(centercode == ce & studycode == grpstruct.ce(ce).studies{3,s} & groupcode_excl == g & conditioncode == co);
                    if n == 1
                       kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).dirdiff(:,1);
                    elseif n == 2
                       kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub;
%                     elseif n == 3
%                        kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).crossdiff(:,1);
                    elseif n == 4
                       kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).alldiff(:,1);
                    end
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    if isfile(tablefn)
        delete (tablefn);
    end
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput;

end

% Merged studies
for n = 1:size(kdmethods,2)

    kDOutput = table('Size',[nsubj 2],'VariableTypes',tvartypes, 'VariableNames',{'CONN_ID', 'kD'});
    kDOutput.(1) = Covariates.CONNID;
    kDOutput.(2)(:) = NaN;
    for ce = 1:grpstruct.ncenters
        for g = 1:grpstruct.ce(ce).all.ngroups
            for co = 1:nconditions  
                includeid = Covariates.CONNID(centercode == ce & groupcode_excl == g & conditioncode == co);
                if n == 1
                   kDOutput.(2)(includeid) = kD.ce(ce).all.g(g).co(co).dirdiff(:,1);
                elseif n == 2
                   kDOutput.(2)(includeid) = kD.ce(ce).all.g(g).co(co).halfdiff.meanpersub;
                elseif n == 3
                   kDOutput.(2)(includeid) = kD.ce(ce).all.g(g).co(co).crossdiff(:,1);
                elseif n == 4
                   kDOutput.(2)(includeid) = kD.ce(ce).all.g(g).co(co).alldiff(:,1);
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'_mergedStudies.xlsx');
    if isfile(tablefn)
        delete (tablefn);
    end
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput;

end

clear tvartypes ce s g co n;

retval = 0;
end
