%% License information
% This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
% You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. 

%% Function calculate_kd starts here

function retval = calculate_kd_v240215 (atlas, scrubbing, skipd, skipkd, excloutliers, reimportcov)
%% Global variables
% clc;
% clear all;
close all;
% rootdir='/media/user/Daten04/ms_kd_cognition_mainproject/bct/';
rootdir='/path_to_data/';

%% Load libraries and change directory

addpath(genpath('/path_to_spm'));
addpath(genpath('/path_to_bct/')); % Add path to brain connectivity toolbox here
addpath(genpath(strcat(rootdir,'scripts'))); % Add path to the folder where scripts are stored if different from rootdir

cd(rootdir);

%% Load adjacency matrix

atlases={'conn','bna','5kvoxel';...
    'Adjacency_matrices_conn.mat',...
    '',...
    'Adjacency_matrices_5kVoxel.mat'};

% atlas=2;

if scrubbing == 1
    if atlas == 1 || atlas == 2
        appendix = '_censored';
    else
        appendix = '';
    end
else
    appendix = '';
end

if excloutliers == 1
    appendix = strcat(appendix,'_excl');
else
    appendix = '';
end

if ( skipkd == 0 && skipd == 0 ) || reimportcov == 1
    %% Import data from spreadsheet

    % Auto-generated by MATLAB on 2023/07/25 13:38:21

    % Import the data
    [~, ~, raw] = xlsread(strcat(rootdir,'/Covariates.xlsx'),'Covariates - columns');
    raw = raw(2:end,:);
    raw(cellfun(@(x) ~isempty(x) && isnumeric(x) && isnan(x),raw)) = {''};
    stringVectors = string(raw(:,[9,11,22]));
    stringVectors(ismissing(stringVectors)) = '';
    raw = raw(:,[1,2,3,4,5,6,7,8,10,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]);

    % Replace non-numeric cells with NaN
    R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
    raw(R) = {NaN}; % Replace non-numeric cells

    % Create output variable
    data = reshape([raw{:}],size(raw));

    % Create table
    Covariates = table;

    % Allocate imported array to column variable names
    Covariates.CONNID = data(:,1);
    Covariates.StudyID = data(:,2);
    Covariates.Group = data(:,3);
    Covariates.Center = data(:,4);
    Covariates.Study = data(:,5);
    Covariates.Sessions = data(:,6);
    Covariates.PatientsALL = data(:,7);
    Covariates.ControlsALL = data(:,8);
    Covariates.DATASET = categorical(stringVectors(:,1));
    Covariates.REPETITION_TIME = data(:,9);
    Covariates.SEX = categorical(stringVectors(:,2));
    Covariates.SEX_MALE = data(:,10);
    Covariates.SEX_FEMALE = data(:,11);
    Covariates.AGE = data(:,12);
    Covariates.AGE_SUB_MEAN = data(:,13);
    Covariates.HEIGHT = data(:,14);
    Covariates.WEIGHT = data(:,15);
    Covariates.BMI = data(:,16);
    Covariates.DIAG_YEARS = data(:,17);
    Covariates.DIAG_YEARS_TO_AGE = data(:,18);
    Covariates.DIAG_YEARS_SUB_MEAN = data(:,19);
    Covariates.TYPE = categorical(stringVectors(:,3));
    Covariates.TYPE_RR = data(:,20);
    Covariates.TYPE_SP = data(:,21);
    Covariates.TYPE_PP = data(:,22);
    Covariates.EDSS = data(:,23);
    Covariates.EDSS_SUB_MEAN = data(:,24);
    Covariates.SDMT = data(:,25);
    Covariates.SDMT_SUB_MEAN = data(:,26);
    Covariates.FSMC = data(:,27);
    Covariates.FSMC_SUB_MEAN = data(:,28);
    Covariates.BBS = data(:,29);
    Covariates.BBS_SUB_MEAN = data(:,30);
    Covariates.TUG = data(:,31);
    Covariates.TUG_LOG = data(:,32);
    Covariates.TUG_SUB_MEAN = data(:,33);
    Covariates.MSIS = data(:,34);
    Covariates.MSWS = data(:,35);
    Covariates.EXCLUDE_from_Analysis = data(:,36);
    Covariates.QC_MaxMotion = data(:,37);
    Covariates.QC_MaxMotion2 = data(:,38);
    Covariates.QC_MeanMotion = data(:,39);
    Covariates.QC_MeanMotionMean2SD = data(:,40);
    Covariates.Exclude_Outliers = data(:,41);
    Covariates.GM_VOL = data(:,42);
    Covariates.MEAN_FA = data(:,43);
    Covariates.LL = data(:,44);
    Covariates.LL_LOG = data(:,45);

    % Clear temporary variables
    clearvars data raw stringVectors R;
end
        
if skipkd == 0
    if skipd == 0

        load (atlases{2,atlas})

        nconditions = matrices.nconditions;
        Z = matrices.condition(1).Z;
        % names = matrices.condition(1).names;
        nsubj = size(matrices.condition(1).Z,3);
        conditioncode = zeros (nsubj,1) + 1;
        Zsize = nsubj * nconditions;
        nrois = size(matrices.condition(1).Z,1);

        if nconditions > 1
            for c = 2:nconditions
                Z = cat(3,Z,matrices.condition(c).Z);
                conditioncode = cat(1,conditioncode,conditioncode * c);
            end
        end

        clear c;

        %% Find missing data

        missingdata = zeros (Zsize,1);

        for s = 1:Zsize
           if sum(sum(isnan(Z(:,:,s)))) > nrois
               missingdata(s) = 1;
           end
        end

        clear s;
		
        
        %% Import ROI definitions and brain mask overlap, discard connections outside the brain
        if scrubbing == 1
            if atlas == 1
                importf = 'mask_overlap_CONN.xlsx';
            elseif atlas == 2
                importf = 'mask_overlap_BNA.xlsx';
            end
            if atlas == 1 || atlas == 2
                othresh = 50;

                % Import data from spreadsheet
                % Auto-generated by MATLAB on 2022/11/09 09:56:42

                % Import the data
                [~, ~, raw] = xlsread(strcat(rootdir,importf));
                raw = raw(2:end,:);
                stringVectors = string(raw(:,2));
                stringVectors(ismissing(stringVectors)) = '';
                raw = raw(:,[1,3,4,5]);

                % Create output variable
                data = reshape([raw{:}],size(raw));

                % Create table
                maskoverlap = table;

                % Allocate imported array to column variable names
                maskoverlap.ID = data(:,1);
                maskoverlap.Mask = stringVectors(:,1);
                maskoverlap.Original_vol = data(:,2);
                maskoverlap.Masked_vol = data(:,3);
                maskoverlap.Percent = data(:,4);

                % Clear temporary variables
                clearvars data raw stringVectors;

                keepvec = maskoverlap.Percent;
                keepvec(keepvec < othresh) = 0;
                keepvec(keepvec > othresh) = 1;
                discardind = find(keepvec == 0);

                Z(discardind,:,:) = [];
                Z(:,discardind,:) = [];
                nrois = size(Z,1);
%                 appendix = '_censored';
            else
%                 appendix = '';
            end
%         else
%             appendix = '';
        end

        clear maskoverlap;
        %% Threshold matrix, get nodal degree

        pthresh = 0.1; % preserve 10 % connections (Mansour et al. 2016)

        plabel = strcat(num2str(pthresh * 100),"pct");

        Zthr = Z * 0;

        for s = 1:Zsize
            if missingdata(s) ~= 1
                Zthr(:,:,s) = threshold_proportional(Z(:,:,s),pthresh);
            else
                Zthr(:,:,s) = NaN;
            end
        end

        Zbin = Zthr;
        Zbin(Zbin ~= 0) = 1;

        % Visualize

        % imagesc(Zthr(:,:,1));
        f = imagesc(nanmean(Zbin,3));
        saveas(f,strcat('figures/Mean_Zbin_',plabel,'_',atlases(1,atlas),appendix,'.jpg'));


        % Get nodal degree

        D.raw = zeros (Zsize,nrois);

        for s = 1:Zsize
            if missingdata(s) ~= 1
                D.raw(s,:) = degrees_und (Zbin(:,:,s));
            else
                D.raw(s,:) = NaN;
            end
        end
        
        roinames = matrices.condition(1).names;

        clear f s Zthr Z Zbin matrices;
		
        save (strcat('D_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));

    else
        % The following code with temporary storage fixes a known bug, that would overwrite any previously saved variables
        tmpstring = strcat('Temporary_init_workspace_',string(atlases(1,atlas)),string(appendix),'.mat');
        save (tmpstring);
        load (strcat('D_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
        load (tmpstring);
        clear tmpstring
    end

    %% Set groups

    centers = {'Germany';'DE'};
    ncenters = size(centers,2);
    groups = {'Patients','Controls'; 'Pat','HC'};
    ngroups = size(groups,2);
    studies = {'MSkD';'MSkD'};
    nstudies = size(studies,2);
    
    conditions = {'Baseline'; 'Baseline'};
    controlgrp = 2;
    controlcond = 1;

    % Define centers, studies and groups
    grpstruct.centers = centers;
    grpstruct.ncenters = ncenters;

    for ce = 1:grpstruct.ncenters
        grpstruct.ce(ce).studies = studies;
        grpstruct.ce(ce).nstudies = nstudies;
        for s = 1:grpstruct.ce(ce).nstudies
            grpstruct.ce(ce).s(s).groups = groups;
            grpstruct.ce(ce).s(s).ngroups = ngroups;
        end
	end
	
    % Setup exclusion
	condition(1).exclude = Covariates.EXCLUDE_from_Analysis == 1 | missingdata(conditioncode == 1) == 1;
    if excloutliers
        condition(1).exclude = condition(1).exclude == 1 | Covariates.Exclude_Outliers == 1;
    end
    % Code exmple for two conditions
    % condition(1).exclude = Covariates.EXCLUDE_from_Analysis == 1 | missingdata(conditioncode == 1) == 1 | (Covariates.Group == 2 & Covariates.ControlsNoMotionMatchedV0 == 0);
    % condition(2).exclude = Covariates.EXCLUDE_from_Analysis == 1 | Covariates.ExcludeMotion_V3 == 1 | (missingdata(conditioncode == 2) == 1 & Covariates.Group == 1) | (Covariates.Group == 2 & Covariates.ControlsNoMotionMatchedV3 == 0);
    % condition(2).exclude = Covariates.ExcludeMotion_V0 == 1 | Covariates.ExcludeMotion_V3 == 1 | missingdata(conditioncode == 2) == 1 | (Covariates.Group == 2 & Covariates.ControlsNoMotionMatchedV3 == 0);

    groupcode = Covariates.Group;
    if nconditions > 1 
        for c = 2:nconditions
            groupcode = cat(1,groupcode,Covariates.Group);
        end
    end

    centercode = Covariates.Center;
    if nconditions > 1 
        for c = 2:nconditions
            centercode = cat(1,centercode,Covariates.Center);
        end
    end

    studycode = Covariates.Study;
    if nconditions > 1 
        for c = 2:nconditions
            studycode = cat(1,studycode,Covariates.Study);
        end
    end

    excludecode = condition(1).exclude;
    if nconditions > 1 
        for c = 2:nconditions
            excludecode = cat(1,excludecode,condition(c).exclude);
        end
    end

    condition(1).excludeid = Covariates.CONNID(condition(1).exclude);
    % condition(2).excludeid = Covariates.CONNID(condition(2).exclude);

    % groupcode_excl = groupcode_comb; % Exclude Ment_Rot effectively
    groupcode_excl = groupcode;
    groupcode_excl(excludecode == 1) = 0;

    % Copy control data from V0 to V3

    % copyfrom = cat(1,Covariates.ControlsNoMotionMatchedV3,Covariates.ControlsNoMotionMatchedV3 .* 0);
    % copyto = cat(1,Covariates.ControlsNoMotionMatchedV3 .* 0,Covariates.ControlsNoMotionMatchedV3);

    % D.raw(find(copyto),:) = D.raw(find(copyfrom),:); 

    % Get V0 - V3 matching indices

    % patientsv3index = find(Covariates.PatientsNoMotionV3(Covariates.PatientsNoMotion == 1));
    % controlsv3index = find(Covariates.ControlsNoMotionMatchedV3(Covariates.ControlsNoMotionMatchedV0 == 1));

    % Get group D, mean and differences

    for g = 1:ngroups
        for co = 1:nconditions
            D.all.g(g).co(co).raw = D.raw(groupcode_excl == g & conditioncode == co,:);
            D.all.g(g).co(co).mean = mean(D.all.g(g).co(co).raw,1);
        end
    end
    
    for g = 1:ngroups
        for co = 1:nconditions
            D.all.g(g).co(co).alldiff = D.all.g(g).co(co).raw - D.all.g(controlgrp).co(controlcond).mean;
        end
    end

    D.nel = 0;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    D.ce(ce).s(s).g(g).co(co).raw = D.raw(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co,:);
                    grpstruct.ce(ce).s(s).g(g).co(co).size = size(D.ce(ce).s(s).g(g).co(co).raw,1);
                    D.ce(ce).s(s).g(g).co(co).mean = mean(D.ce(ce).s(s).g(g).co(co).raw,1);
                    D.nel = D.nel + 1;
                end
            end
        end
    end

    for ce = 1:grpstruct.ncenters
        grpstruct.ce(ce).controlsize = sum(centercode == ce & groupcode_excl == controlgrp & conditioncode == controlcond);
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    D.ce(ce).s(s).g(g).co(co).dirdiff = D.ce(ce).s(s).g(g).co(co).raw - D.ce(ce).s(s).g(controlgrp).co(controlcond).mean;
                    D.ce(ce).s(s).g(g).co(co).alldiff = D.ce(ce).s(s).g(g).co(co).raw - D.all.g(controlgrp).co(controlcond).mean;
                end
            end
        end
    end
    
    maxall = zeros(1,D.nel);
    minall = zeros(1,D.nel);
    i=1;
    for ce = 1:ncenters
        for s = 1:nstudies
            for g = 1:ngroups
                for co = 1:nconditions
                    maxall(i) = max(D.ce(ce).s(s).g(g).co(co).mean);
                    minall(i) = min(D.ce(ce).s(s).g(g).co(co).mean);
                    i=i+1;
                end
            end
        end
    end
    minmaxall = [min(minall) max(maxall)];

    imgscmat = zeros (D.nel,nrois);
    imgsclabel = cell(1, D.nel);
    imgscticks = zeros(1,D.nel);
    r = 1;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    imgscmat(r,:) = D.ce(ce).s(s).g(g).co(co).mean;              
                    imgsclabel(1,r) = strcat(centers(2,ce),'-',studies(2,s),'-',groups(2,g),'-',conditions(2,co)); %studies(2,s)
                    imgscticks(1,r) = r;
                    r = r + 1;
                end
            end
        end
    end
    f = imagesc(imgscmat);
    ax = gca;
    ax.YTick = imgscticks;
    ax.YTickLabel = imgsclabel;
    saveas(f,strcat('figures/Mean_D_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

    close all;
    clear f r ce s g co c imgsclabel imgscticks imgscmat ax;

    %% Distribution of D
    % Not universal

    nbins = 20;
    if atlas == 1
        ylims = [0 20];
    elseif atlas == 2
        ylims = [0 40];
    else
        ylims = [0 700];
    end

    xlims = [0 minmaxall(2)];

    for ce = 1:ncenters
        for co = 1:nconditions
            f = figure('Name','D distribution');

            set(gcf,'position',[100,100,400,800])
            
            for g = 1:ngroups
                for s = 1:nstudies
                    subploth = subplot(ngroups,nstudies,s+(g-1).*nstudies);
                    histogram(D.ce(ce).s(s).g(g).co(co).mean,nbins)
                    ylim(subploth, ylims);
                    xlim(subploth, xlims);
                    title(strcat(groups(2,g),'-',studies(2,s)));
                end
            end
            
            saveas(f,strcat('figures/D_histogram_',centers(2,ce),'_',...
                conditions(2,co),'_',plabel,'_',atlases(1,atlas),appendix,'.tif'));
            close all;
        end
    end
    
    clear f ylims xlims nbins subploth;

    %% CDF plots
    % Not universal
      
    for ce = 1:ncenters
        for co = 1:nconditions

            f = figure('Name','CDF');

            i=1;
            for g = 1:ngroups
                for s = 1:nstudies
                    if ~isnan(nanmean(D.ce(ce).s(s).g(g).co(co).mean))
                        cdfplots(i) = cdfplot(D.ce(ce).s(s).g(g).co(co).mean);
                        legends(i) = strcat(groups(2,g),"-",studies(2,s));
                        hold on
                        i=i+1;

%                     else
%                         legends(i) = strcat(groups(2,g),"-",studies(2,s),'-EMPTY');
                    end
                end
            end
            
            xvals = linspace(minmaxall(1),minmaxall(2));
            cdfplots(i) = plot(xvals,normcdf(xvals,mean(D.all.g(controlgrp).co(controlcond).mean),std(D.all.g(controlgrp).co(controlcond).mean)),'r-');
            legends(i) = {'Normal'};
            
            title('CDF Mean Degree');
            
            legend(cdfplots,legends,'Location','southeast');

            saveas(f,strcat('figures/D_cdf_',centers(2,ce),'_',...
                conditions(2,co),'_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

            close all;
            
        end
    end
    
    clear cdfplots legends;
    
    f = figure('Name','CDF_merged');

    i=1;
    for g = 1:ngroups
        for co = 1:nconditions
            cdfplots(i) = cdfplot(D.all.g(g).co(co).mean);
            legends(i) = strcat(groups(2,g),"-",conditions(2,co));
            hold on
            i=i+1;
        end
    end

    xvals = linspace(minmaxall(1),minmaxall(2));
    cdfplots(i) = plot(xvals,normcdf(xvals,mean(D.all.g(controlgrp).co(controlcond).mean),std(D.all.g(controlgrp).co(controlcond).mean)),'r-');
    legends(i) = {'Normal'};

    title('CDF Mean Degree Merged');

    legend(cdfplots,legends,'Location','southeast');

    [h1,p1] = kstest2(D.all.g(1).co(1).mean,D.all.g(2).co(1).mean);

    textboxdim1 = [0.16 0.6 0.3 0.3];
    textboxstr1 = {strcat(groups(2,1)," - ", groups(2,2),": p=",num2str(p1))};
    annotation('textbox',textboxdim1,'String',textboxstr1,'FitBoxToText','on');

    saveas(f,strcat('figures/D_cdf_merged_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

    close all;
           
    clear f textboxdim1 textboxstr1 h1 p1 cdfplots legends xvals;

    %% Compare D
    % Not universal

    close all;

    p(1).v = zeros(nrois,1) + 1;
    h(1).v = zeros(nrois,1);

    for roi = 1:nrois
        [p(1).v(roi),h(1).v(roi)] = ranksum(D.all.g(1).co(1).raw(:,roi),D.all.g(2).co(1).raw(:,roi));
    end

    hcor(1).v = zeros(size(p(1).v,1),1);
    pcor=0.05./nrois;
    hcor(1).v(p(1).v < pcor) = 1;
    
    f = imagesc([p(1).v,h(1).v,hcor(1).v]); % p(2).v,h(2).v,p(3).v,h(3).v,p(4).v,h(4).v]);
    ax = gca;
    ax.XTick = 1:3;
    ax.XTickLabel = [strcat(groups(2,1)," - ",groups(2,2)),{'h'},{"h (Bonferroni)"}];
    xtickangle (90);
    if atlas == 1
        ax.YTick = 1:nrois;
        ax.YTickLabel = roinames;
        set(gcf,'position',[50,50,800,2000]);
        ax.FontSize = 6;
    end
    saveas(f,strcat('figures/D_diff_',plabel,'_',atlases(1,atlas),appendix,'.tif'));

    close all;
    clear f p h ax;


    %% Get kD

    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    kD.ce(ce).s(s).g(g).co(co).dirdiff = zeros(size(D.ce(ce).s(s).g(g).co(co).dirdiff,1),2);
                    kD.ce(ce).s(s).g(g).co(co).alldiff = zeros(size(D.ce(ce).s(s).g(g).co(co).alldiff,1),2);
                    for su = 1:size(kD.ce(ce).s(s).g(g).co(co).dirdiff,1)
                        kD.ce(ce).s(s).g(g).co(co).dirdiff(su,:) = polyfit(D.ce(ce).s(s).g(controlgrp).co(controlcond).mean, D.ce(ce).s(s).g(g).co(co).dirdiff(su,:),1);
                        kD.ce(ce).s(s).g(g).co(co).alldiff(su,:) = polyfit(D.all.g(controlgrp).co(controlcond).mean, D.ce(ce).s(s).g(g).co(co).alldiff(su,:),1);
                    end
                end
            end
        end
    end
    
    for g = 1:ngroups
        for co = 1:nconditions
            kD.all.g(g).co(co).alldiff = zeros(size(D.all.g(g).co(co).alldiff,1),2);
            for su = 1:size(kD.all.g(g).co(co).alldiff,1)
                kD.all.g(g).co(co).alldiff(su,:) = polyfit(D.all.g(controlgrp).co(controlcond).mean, D.all.g(g).co(co).alldiff(su,:),1);
            end
        end
    end

    clear g ce co s su;

    %% Get kD permuted with random half controls - fixed

    nperms = 0; % Permutation counter
    minperms = 100; % Set target number of permutations
    permsdone = false;

    for ce = 1:ncenters
        % Get the size of the halved control group, ignore studies
        grpstruct.ce(ce).perm.halfcontrolsize = fix(grpstruct.ce(ce).controlsize/2);
        for s = 1:grpstruct.ce(ce).nstudies
            grpstruct.ce(ce).s(s).perm.nassig = zeros(grpstruct.ce(ce).controlsize,2); %column 1 - for normalisation, 2 - for t-test
        end
    end

    % Declare empty containers

    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm = zeros(size(D.ce(ce).s(s).g(g).co(co).raw,1),minperms);
                    D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).raw * 0;
                    if g == controlgrp
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm == 0) = NaN;
                        D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).s(s).g(g).co(co).raw * 0;
                    end
                end
            end
        end
    end

    % Start permutations here
    while (permsdone == false)
        nperms = nperms + 1;
        % Set random control groupsPat_DE
        permcode = groupcode_excl * 0;

        % For each center
        for ce = 1:ncenters
            % Chose a random sample from the control groups (ignore division
            % into studies)
            grpstruct.ce(ce).perm.cons4norm = randsample(find(centercode == ce & groupcode_excl == controlgrp),grpstruct.ce(ce).perm.halfcontrolsize);
            permcode(grpstruct.ce(ce).perm.cons4norm) = 1; % For normalization
            permcode(permcode == 0 & centercode == ce & groupcode_excl == controlgrp) = 2; % For t-test
        end

        % For each center, study, group, condition
        for ce = 1:grpstruct.ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    for co = 1:nconditions
                        % If condition is control condition (e.g., baseline)
                        % and group is control group
                        if co == controlcond && g == controlgrp
                            % Extract degree for the testing set, set controls for normalization to NaN
                            D.temp = D.raw;
                            D.temp(permcode == 1,:) = NaN;
                            D.ce(ce).s(s).g(g).co(co).halfdiff.forttest_raw = D.temp(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co,:);                       
                            % Extract degree for the normalization set
                            D.temp = D.raw;
                            D.temp(permcode == 2,:) = NaN;
                            D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw = D.temp(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co,:);
                            % Get average degree
                            D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_mean = nanmean(D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw);
                        end
                    end
                end
            end
        end

        for ce = 1:grpstruct.ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                for g = 1:grpstruct.ce(ce).s(s).ngroups
                    for co = 1:nconditions
                        % If condition is control condition (e.g., baseline)
                        % and group is control group
                        if co == controlcond && g == controlgrp
                            % Calculate the degree difference
                            D.ce(ce).s(s).g(g).co(co).halfdiff.diff = D.ce(ce).s(s).g(g).co(co).halfdiff.forttest_raw ...
                                - D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                        % For all remaining cases if permutation counter is lower or equal to
                        % target number
                        elseif nperms <= minperms
                            % Calculate the degree difference
                            D.ce(ce).s(s).g(g).co(co).halfdiff.diff = D.ce(ce).s(s).g(g).co(co).raw ...
                                - D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean;
                        end

                        % Calculate kD 
                        % If permutation counter is lower or equal to
                        % target number or if control group is computed
                        if nperms <= minperms || ( co == controlcond && g == controlgrp ) 
                            kD.ce(ce).s(s).g(g).co(co).halfdiff.single = zeros(size(D.ce(ce).s(s).g(g).co(co).halfdiff.diff,1),2);
                            for su = 1:size(D.ce(ce).s(s).g(g).co(co).halfdiff.diff,1)
                                kD.ce(ce).s(s).g(g).co(co).halfdiff.single(su,:) = ...
                                    polyfit(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_mean, ...
                                    D.ce(ce).s(s).g(g).co(co).halfdiff.diff(su,:),1);
                            end
                            % Store kD separately for each permutation
                            kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm(:,nperms) = kD.ce(ce).s(s).g(g).co(co).halfdiff.single(:,1);

                            if co == controlcond && g == controlgrp
                                % Remove NaNs
                                D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan = D.ce(ce).s(s).g(g).co(co).halfdiff.diff;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan(isnan(D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan)) = 0;

                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan(isnan(D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan)) = 0;
                                % Add difference in degree to a total sum (to get later mean degree)
                                D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.diff_nonan;
                                D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_raw_nonan;
                            else
                                % Add difference in degree to a total sum (to get later mean degree)
                                D.ce(ce).s(s).g(g).co(co).halfdiff.sum = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ...
                                    + D.ce(ce).s(s).g(g).co(co).halfdiff.diff;
                            end
                        end
                    end
                end
            end
        end

        % Increment assigment counters
        currentmin = minperms;
        for ce = 1:ncenters
            for s = 1:grpstruct.ce(ce).nstudies
                grpstruct.ce(ce).s(s).perm.nassig(:,1) = grpstruct.ce(ce).s(s).perm.nassig(:,1) ...
                    + isnan(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.diff(:,1));
                grpstruct.ce(ce).s(s).perm.nassig(:,2) = grpstruct.ce(ce).s(s).perm.nassig(:,2) ...
                    + isnan(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.fornorm_raw(:,1));
                if (min(grpstruct.ce(ce).s(s).perm.nassig(:,2)) < currentmin)
                    currentmin = min(grpstruct.ce(ce).s(s).perm.nassig(:,2));
                end
            end
        end

        % Check if targent number of permutations was reached in all controls
        if currentmin >= minperms
            % If yes, break loop
            permsdone = true;
        end
    end

    for ce = 1:ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions
                    % For the control group
                    if co == controlcond && g == controlgrp
                        % Get first minperms (100) values for controls, ignore the rest
                        kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans = ...
                            zeros(size(D.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.diff,1),minperms);
                        for su = 1:size(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm,1) 
                            kD.temp = kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm(su,:);
                            kD.temp = kD.temp(~isnan(kD.temp));
                            kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans(su,:) = ...
                                kD.temp(1:minperms);
                        end
                        % Get mean kD for each permutation averaged across subjects (first minperms)
                        % The following line does actually average across
                        % fewer datapoints, but using "nonans" is not informative 
                        % as permutations get mixed with each other.
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanperperm = nanmean(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm(:,1:minperms),1);
                        % Get mean kD for each subject averaged across permutations (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).s(s).g(controlgrp).co(controlcond).halfdiff.perperm_nonans,2);
                        % Get mean degree (for visualization only)
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ./ grpstruct.ce(ce).s(s).perm.nassig(:,2);
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean_fornorm = D.ce(ce).s(s).g(g).co(co).halfdiff.fornorm_sum ./ grpstruct.ce(ce).s(s).perm.nassig(:,1);
                    % For all the remaninig subjects
                    else
                        % Get mean kD for each permutation averaged across subjects (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanperperm = mean(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm,1);
                        % Get mean kD for each subject averaged across permutations (first minperms)
                        kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub = mean(kD.ce(ce).s(s).g(g).co(co).halfdiff.perperm,2);
                        % Get mean degree (for visualization only)
                        D.ce(ce).s(s).g(g).co(co).halfdiff.mean = D.ce(ce).s(s).g(g).co(co).halfdiff.sum ./ minperms;
                    end
                end
            end

        end
    end

    clear s g ce co su permcode permsdone currentmin

    save (strcat('kD_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
    
else
    % The following hotfix with temporary storage fixes a known bug, that would overwrite any previously saved variables
    tmpstring = strcat('Temporary_init_workspace_',string(atlases(1,atlas)),string(appendix),'.mat');

    save (tmpstring);
    
    load (strcat('kD_workspace_',string(atlases(1,atlas)),string(appendix),'.mat'));
    
    load (tmpstring);
    
    clear tmpstring
end

%% Export D
DOutput = array2table(D.raw.');

tablefn = strcat('exports/d_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    delete (tablefn);
    writetable(DOutput,tablefn);
        
clear tvartypes DOutput g co tablefn;

%% Export Ddiff
kdmethods = {'All controls', 'Split controls', 'Crossed controls', 'Pooled controls';...
    'dir','half','crossed','all'};

for n = 1:2
    %DOutput = array2table(D.raw.');
 
    tvartypes = cell(1,nsubj);
    for i = 1:size(tvartypes,2)
        tvartypes(i) = {'double'};
    end

	DOutput = table('Size',[nrois nsubj],'VariableTypes',tvartypes);
    tempnan = zeros(nrois, nsubj);
    tempnan(:,:) = NaN;
    DOutput(:,:) = array2table(tempnan);
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions  
                    includeid = Covariates.CONNID(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co);
                    if n == 1
                       DOutput(:,includeid) = array2table(D.ce(ce).s(s).g(g).co(co).dirdiff(:,:).');
                    elseif n == 2
                       % For control group the mean is actually based on
                       % unequal number of permutations (>minperm) -> To be fixed
                       DOutput(:,includeid) = array2table(D.ce(ce).s(s).g(g).co(co).halfdiff.mean.');
                    end
                end
            end
        end
    end
    
    tablefn = strcat('exports/ddiff_',kdmethods(2,n),'_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    
    delete (tablefn);
    writetable(DOutput,tablefn);
    
    clear tablefn tempnan DOutput;

end

clear tvartypes ce s g co n;
       
%% Export kD

tvartypes = cell(1,ngroups+1);

tvartypes(1) = {'int16'};
for g = 1:ngroups
    tvartypes(g+1) = {'double'};
end

for n = 1:2

    kDOutput = table('Size',[nsubj ngroups + 1],'VariableTypes',tvartypes, 'VariableNames',[{'CONN_ID'} groups(1,:)]);
    kDOutput.(1) = Covariates.CONNID;
    
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions    
                    includeid = Covariates.CONNID(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co);       
                    kDOutput.(g+1)(:) = NaN;
                    if n == 1
                       kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).dirdiff(:,1);
                    elseif n == 2
                       kDOutput.(g+1)(includeid) = kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub;
                    end
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_byGrp_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    delete (tablefn);
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput ce s g co;

end

clear tvartypes n;

% Merged output for SPSS
tvartypes = {'int8', 'double'};

for n = 1:2

    kDOutput = table('Size',[nsubj 2],'VariableTypes',tvartypes, 'VariableNames',{'CONN_ID', 'kD'});
    kDOutput.(1) = Covariates.CONNID;
    kDOutput.(2)(:) = NaN;
    for ce = 1:grpstruct.ncenters
        for s = 1:grpstruct.ce(ce).nstudies
            for g = 1:grpstruct.ce(ce).s(s).ngroups
                for co = 1:nconditions  
                    includeid = Covariates.CONNID(centercode == ce & studycode == s & groupcode_excl == g & conditioncode == co);
                    if n == 1
                       kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).dirdiff(:,1);
                    elseif n == 2
                       kDOutput.(2)(includeid) = kD.ce(ce).s(s).g(g).co(co).halfdiff.meanpersub;
                    end
                end
            end
        end
    end
    
    tablefn = strcat('exports/kd_',kdmethods(2,n),'_controls_',plabel,'_',atlases(1,atlas),appendix,'.xlsx');
    delete (tablefn);
    writetable(kDOutput,tablefn);
    
    clear tablefn kdOutput;

end

clear tvartypes kDOutput ce s g co n;

